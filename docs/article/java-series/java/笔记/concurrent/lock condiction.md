lock 解决互斥问题  
condition 解决同步问题  

## 死锁

- 死锁
  - 原因  
    线程互斥，占有且不释放，不可抢占，循环等待
  - 解决方法
   - 事前  
     设置良好的通信、协调机制  
     - 等待超时  
     - 发现条件不满足，自动退让  
     - 支持中断响应  
   - 事中  
     - 检测和kill 线程  
   - 事后  

## lock

- 支持等待超时  
- 发现条件不满足，自动退让  
- 支持中断响应  

加锁: state  += 1  
解锁: state -= 1  

### 原理

#### 可见性 原子性 有序性

假设 t1 的 lock 先于 t2 的 lock ，则

- t1 的 lock 先于 t1 的 unlock
- t2 的 lock 先于 t2 的 unlock
- t1 的 ？？

## condition

### 等待队列

不满足的时候，如何进入等待，如何退出 ？？

#### 异步转同步

通过先执行 await 阻塞 RPC 线程，然后在回调函数中 signalAll() 唤醒阻塞线程，且传递进去。  

#### dubbo

即便是用NIO，也是需要 await 和 signAll() ？