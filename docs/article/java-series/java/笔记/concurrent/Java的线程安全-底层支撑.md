# 概述

## 读前须知

这篇文章我改了3遍才改成这个鸟样，估计再改30遍也不能让人满意。  
所以呢，你看这篇文章应该有很多疑问，看之前最好那个小本本记好 TODO 和 FAQ ，然后写在评论区，尽管我很有可能不回复（拉波仇恨），不代表掘友不回复。  
如果你仅仅是想对 Java 并发编程有一个整体上的、系统的（不细致的）了解，这篇文章还是能有所帮助的（我尽量做到不挖坑埋人）。  
这篇文章仅适合对 Java 多线程有点基础的同学，不适合大牛也不适合小牛，也不适合面试（后续我还是会写篇对面试有帮助的文章）。  

我为啥起名叫底层支持，而不是底层原理，因为我觉得只是把逻辑捋顺还不能称之为原理，就好像知道了 API 的定义和使用方法，断然不能说你了解了 API 的实现逻辑。  
下面一段是废话（尽管上面可能也是一堆废话），看干货的可以直接跳过。  

我个人的观点：从逻辑上讲，并发编程知识并非十分高深，但是里面涉及很多繁杂的概念，且需要的纵向知识比较多一点。  
但是计算机语言知识往往是按层来分的，比如硬件-->汇编语言-->C/C++-->Java/Python/PHP/JavaScript，所以并发编程会显得比较“深”。  
而且有些知识因为中外语言的差异，以及本身技术理论本身传达就容易发生偏差等原因，导致很多非技术因素干扰我们的学习，所以并发编程会显得比较“难”。  

## 为啥会出现多线程

不讲为啥会出现多线程，线程和进程的关系也不讲，他们俩在内存和 CPU 上咋“玩游戏”的也不讲，内核线程和用户线程也不讲，CPU核数（这里的核和前面的核实一个核吗？）和线程关系也不讲。这里要聚焦在安全这个话题上。  

## 为啥会出现线程不安全

```
/**
 * 假设多个线程只能操作 store 和 load 方法
 * @author zhangln
 *
 */
public class VolatileExample {

    int a = 0;
    int b = 1;

    public void store() {
        a = 2;
        b = 3;
    }

    public void load() {
        // 这里的 b 可能是多少？
        if (a > 0) {
            // 这里的 b 可能是多少？
        }
    }
}
```

因为 Java 编译器和 CPU 都可能做重排序。  

### 可见性

### 原子操作

### 重排序（或者说有序性）

常见的处理器都不允许对存在数据依赖的操作做重排序（这里说的是以单线程为前提），但是部分处理器，允许写-读操作重排序。  
啥叫数据依赖？比如： `a = 1, b = 1 ;` 两个语句之间没有依赖，他们重排序没问题； `a = 1 , b = a + 1 ;` 两个语句之间就有数据依赖，断然不能重排序。  

所以即便 CPU 可以乱序执行也要遵循 as-if-serial （这是个单线程内的概念） 原则。其语义是：不管怎么重排序，（单线程）程序的结果不能被改变。比如 `a = 1, b = 1 , c = a + b ；` 怎么乱序执行，都不应该出现 `c = 1` 的结果，其实还是遵循了不能破坏数据依赖的原则。  
即便如此，显然在多线程的情况下还是会出现异常。

现在我们可以罗列出其中两种可能的执行情况： 

情况1：
| 线程A     | 线程 B |
| --------- | ------ |
| int a = 0 | xxx    |
| int a = 0 | xxx    |

情况2：
| 线程A     | 线程 B |
| --------- | ------ |
| int a = 0 | xxx    |
| int a = 0 | xxx    |

## 硬件相关的术语

这些术语了解一下，以便理解后面内容。

| 中文翻译     | 术语                   | 解释                                                                                                                                                                                                                                         |
| ------------ | ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 内存屏障     | memory barriers        | 一组处理器指令，实现对内存操作的顺序限制                                                                                                                                                                                                     |
| 原子操作     | Atomic operations      | 不可中断的一个或者一系列操作                                                                                                                                                                                                                 |
| 缓冲行       | cache line             | 缓冲中可以分配的最小存储单元。处理器填写缓存线时，会加载整个缓存线，需要使用多个主内存读周期（这里我也不懂什么叫缓冲行，缓存线，对应了硬件的什么区域，但是并不影响下面的阅读）                                                               |
| 缓冲行填充   | cache line fill        | 如果处理器识别到从内存中读取的操作数是可缓存的，可以将缓存行读取并放入到缓存（L1,L2,L3的或所有）                                                                                                                                             |
| 比较并交换   | Compare and Swap       | CAS 操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。                                                                                   |
| CPU 流水线   | CPU pipeline           | CPU 流水线的工作方式就象工业生产上的装配流水线，在 CPU 中由 5~6 个不同功能的电路单元组成一条指令处理流水线，然后将一条 X86 指令分成 5~6 步后再由这些电路单元分别执行，这样就能实现在一个 CPU 时钟周期完成一条指令，因此提高 CPU 的运算速度。 |
| 内存顺序冲突 | Memory order violation | 内存顺序冲突一般是由假共享引起，假共享是指多个 CPU 同时修改同一个缓存行的不同部分而引起其中一个 CPU 的操作无效，当出现这个内存顺序冲突时，CPU 必须清空流水线。                                                                               |

我们都知道线程安全是因为无法保证下面3个方面（原子性、可见性、有序性）导致的，接下来就每个方面来展开聊聊吧。  

## 如何解决线程不安全的问题

### 原子操作

处理器使用基于对 “缓存加锁或总线加锁” 的方式来实现多处理器之间的原子操作，更多详情这不再展开叙述，可以看 《Java并发编程的艺术》（这本书里我看了半天 2.3 章节，觉得怎么只讲对数据操作的原子性啊？后来想想也是，数据库事务本质上保证的也是数据操作的原子性）。  

不过如果只能保证单操作的原子性，比如读一个值、写一个值的话，那岂不是太局限了，可不可以像数据库一样来保证一组操作不被拆开呢？我认为不可以，即便是数据库本质上也没有办法保证（加锁的）多条语句是打包执行的。  
不过好在 JMM （Java 内存模型） 规范提供了一套机制，来保证即便是多线程的情况下，也可以有序执行，这种有序性从其实就保证了多个操作不被拆开。  

### 可见性和有序性

从 JDK 5 开始，Java 使用新的 JSR-133 内存模型（本文都是以此为基础来讲述线程安全性的）。 JSR-133使用 happens-before 的概念来阐述操作之间的内存可见性。  
通过一系列的可见性的规则，进而保证了程序的有序性，最终也就“实现了”上面期望的（加锁的）多条语句打包执行。  

happens-before 本质上是要消除缓存引起的脏读，可以理解为前面的操作结果相对于后面的读操作必须可见，即并没有要消除 CPU 乱序的意思。  
如前所述，通过保证可见性，进而实现了多线程下程序执行的有序性（这是我自己的表达，要权威描述还是看官方文档吧）。  

happens-before 里面有4条很重要的规则：  

1. 程序的顺序性规则  
  一个线程中的操作，happens-before 于其后的任意操作。  
  和前面的 as-if-serial 基本一个意思： 前面的操作结果对后续操作可见，不管怎样编译优化、乱序执行。  
2. 监视器锁（synchronized)规则  
  对一个锁的解锁，happen-before 于随后的对这个锁的加锁。（对底层了解比较深的，应该知道 synchronized 本质上是使用管程实现的，我们这里既不会聊管程，也不会聊信号量，否则又要触及 OS 的一些知识，不过 JCU 里确实也提供了“管程”和“信号量”）  
3. volatile 变量规则  
  对一个 volatile 域的写，happen-before 于其后任意对 volatile 域的读。  
4. 传递性  
  指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。  
  特别强调的是即便是在多线程中，也保证这个规则。  

还有 3 条和线程生命周期/对象生命周期相关的规则：

1. 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
2. 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
3. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。  
4. 对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。  

最后我们可以再看看，修改后的代码，及其中的问题：

```
/**
 * 假设多个线程只能操作 store 和 load 方法
 * @author zhangln
 *
 */
public class VolatileExample {

    int a = 0;
    volatile int b = 1;

    public void store() {
        a = 2;
        b = 3;
    }

    public void load() {
        // 这里的 b 可能是多少？
        if (a > 0) {
            // 这里的 b 可能是多少？
        }
    }
}
```

现在想想，还会出现之前的问题吗？为什么？ 

情况1：
| 线程A     | 线程 B | 能否出现 | 为什么 |
| --------- | ------ | -------- | ------ |
| int a = 0 | xxx    |          |        |
| int a = 0 | xxx    |          |        |

情况2：
| 线程A     | 线程 B | 能否出现 | 为什么 |
| --------- | ------ | -------- | ------ |
| int a = 0 | xxx    |          |        |
| int a = 0 | xxx    |          |        |

我们再罗列一下可能出现的情况：

情况3：
| 线程A     | 线程 B | 能否出现 | 为什么 |
| --------- | ------ | -------- | ------ |
| int a = 0 | xxx    |          |        |
| int a = 0 | xxx    |          |        |

情况4：
| 线程A     | 线程 B | 能否出现 | 为什么 |
| --------- | ------ | -------- | ------ |
| int a = 0 | xxx    |          |        |
| int a = 0 | xxx    |          |        |

如何验证呢，其实开两个线程，然后打上debug断点就可以溜溜的验证了，这是做数据库不能比拟的（除非他们down 下源码然后DEBUG测试）。

## volatile & synchronized

### volatile

Volatile 变量修饰符如果使用恰当的话,它比 synchronized 的使用和执行成本会更低,因为它不会引起线程上下文的切换和调度。
volatile 变量修饰的共享变量，进行写操作的时候会多出一行汇编代码 （Java 代码转成汇编代码），即一个 Lock 前缀的指令（Lock# 信号），即插入指令屏障。  

### synchronized

使用 monitorenter 和 monitorexit 指令实现，JVM 要保证每个 monitorenter 必须有对应的 monitorexit 与之配对。  
锁存在 Java 对象头里。如果对象是数组类型,则虚拟机用 3 个 Word(字宽)存储对象头,如果对象是非数组类型,则用 2 字宽存储对象头。  
在 32 位虚拟机中,一字宽等于四字节,即 32bit。  
3个字宽分别存储：存储对象的 hashCode 或锁信息等; 存储到对象类型数据的指针； 数组的长度(如果当前对象是数组)。  

Java SE1.6 里锁一共有四种状态,无锁状态,偏向锁状态,轻量级锁状态和重量级锁状态,它会 随着竞争情况逐渐升级。  
锁可以升级但不能降级,意味着偏向锁升级成轻量级锁后不能降级成偏向锁，目的是为了 高获得锁和释放锁的效率。  
