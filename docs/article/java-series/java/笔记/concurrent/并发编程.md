
CPU缓存 和 内存的更新机制和关系  
http://m.elecfans.com/article/634861.html  CPU的核心数、线程数的关系和区别  
从

如果线程切换，那么线程中的内存信息是否会刷新到内存  

## 01 可见性 原子性 有序性

不保证可见性，会因为缓存引发脏读问题  
不保证原子性，会因为线程切换引发问题  
有序性和双检锁

## 02 Java内存模型 / 消除01的问题

内存模型 volatile happen-before规则及传递性  
final 和 双检锁

## 03  synchronized  资源和锁  

## 04 synchronized 资源和锁  
  
原子性本质：中间状态不可见，也不可修改  

## 05 死锁和解决办法

## 06 wait-notify

## 07 安全性/活跃性/性能问题

安全性：是数据竞争引起的  
活跃性：死锁/活锁/饥饿
性能：阿姆达尔定律  吞吐量/并发量/RT

## 08 管程

## 09 Java的生命周期

线程状态监测

## 10 应该创建多少线程才合适

## 11 局部变量是线程安全的

方法栈：方法的地址，栈内变量的值，引用变量的值  
线程封闭：连接池 Connection 采用了线程封闭技术

## 12 编写线程安全的对象

## 13 总结 1~12

锁 私有的、不可变的、不可重用的（Integer 这种是可重用的)
InterruptedException 的坑


### CPU

运算器：正在执行的代码和正在使用的变量，
控制器：
寄存器：堆栈寄存器  

### 内存



## TODO

- 线程和CPU  
  - 单线程多核  
    意味着没有数据共享，是不会发生问题的  
  - 多线程单核  
    现在一般不会有这种现实情况  
  - 多线程多核  
    
happen-before 的几个规则  
管程的实现  
