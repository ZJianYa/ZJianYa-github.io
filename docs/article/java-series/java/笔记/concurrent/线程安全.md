
## 线程安全

原子性，简单说就是相关操作不会中途被其他线程干扰，
可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。
有序性，是保证线程内串行语义，避免指令重排等。

### 底层支持

根本上需要硬件支持，需要 禁止缓存  
- synchronized
- lock condition
指令支持 / 管程 

#### Java 内存模型

简述同步和通信  
资源，锁，锁的粒度  

#### 线程安全-Java编码

lock condition / CAS / Immutable / ThreadLocal  
信号量：可以实现互斥、协同，但是容易死锁，且不能退出，没有Condition的概念的  
管程：考虑了 Condition 即可以实现阻塞队列，可以退出  

##### synchronized

##### Java 类库

JDK 类库大致分为  
同步容器： Collections.synchronizedList(new ArrayList());  Vector Stack HashTable  
并发容器： List（CopyOnWriteArrayList） Map（ConcurrentHashMap ConcurrentSkipListMap） Set  
阻塞队列 非阻塞队列 单端队列 双端队列 有界队列 无界队列  Queue/Deque  
同步结构:  CountDownLatch 、 CyclicBarrier 、 Semaphore    
Executor：  
Future:  
Fork/Join： 

###### lock condition

###### 容器和队列

###### final Immutable

对象是 final 的，其属性也都是 final 的（即不允许子类继承）。  
然后通过享元模式来减少创建重复的对象。  
享元模式本质上是个对象池，比如 Long 内部维护了一个 `[-128,127]` 。  

但是实话说，我们没发现有什么应用场景。

###### copy on write

案例： Linux 系统的 fork() ， String 、 Integer 、 Long 都是（但并不是说都线程安全，确切的说你使用不当会经常不安全）。  
适合读多写少的场景，我个人觉得还是面试的时候用吧，真实需求太少了。  

###### ThreadLocal
