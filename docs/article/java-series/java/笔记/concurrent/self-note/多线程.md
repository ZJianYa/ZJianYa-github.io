## 多线程

### 客观事实

运算器：正在执行的代码和正在使用的变量，  
控制器：  
寄存器：堆栈寄存器  

CPU缓存 和 内存的更新机制和关系  
http://m.elecfans.com/article/634861.html  CPU的核心数、线程数的关系和区别  
从

如果线程切换，那么线程中的内存信息是否会刷新到内存 

- 线程和CPU  
  - 单线程多核  
    意味着没有数据共享，是不会发生问题的  
  - 多线程单核  
    现在一般不会有这种现实情况  
  - 多线程多核  

### 适用场景

首先需要知道度量的指标

OS 已经对 CPU 和 I/O 做了很多基础优化，或者说通用优化。  

CPU 和 I/O 耗时比率  
- 加入都很低，那么通常吞吐量会增加，但是 RT 不会提升
- 硬件：多核  
  单线程 CPU 密集，可以拆为多线程
- 通常是 CPU 时间远 ＜ IO 时间，且 IO 利用率很高，则称之为 IO 密集  
  这时候 线程数量/CPU 数量，其实和 CPU 和 IO 比率有关系，大致上如下：  
  最佳线程数量 = 1 + (I/O 耗时 / CPU 耗时)  
  对于多CPU，则 
  最佳线程数量 = （1 + (I/O 耗时 / CPU 耗时)） * CPU 核数  
  为什么不是一些人说的 线程数量 = 2 * CPU核数 + 1 ，因为 (I/O 耗时 / CPU 耗时) 值可能很大  
- 如果 CPU 时间远远 > IO 时间，则称之为 CPU 密集  
  理论上线程 和 CPU 数量 1:1 ，或者 线程数量 = CPU +1，因为偶尔会内存页失效，导致某个线程阻塞

除此之外，所有的业务都是有时间相关性的，所以在不同的时间，或者其他原因导致 CPU 和 IO 的比率是动态变化的。  
定性的io密集或者cpu密集很难在定量的维度上反应出性能瓶颈，而且公式上忽略了线程数增加带来的cpu消耗，性能优化还是要定量比较好，这样不会盲目，比如io已经成为了瓶颈，增加线程或许带来不了性能提升，这个时候是不是可以考虑用cpu换取带宽，压缩数据，或者逻辑上少发送一些。  

特殊案例：  
公司服务器都是容器，一个物理机分出好多容器，有个哥们设置线程池数量直接就是：Runtime.getRuntime().availableProcessors() * 2；本来想获取容器的CPU数量 * 2，其实Runtime.getRuntime().availableProcessors()获取到的是物理机CPU合数，一下开启了好多线程 ^_^  

统一任务调度，还在于每个 docker 都是一个服务，当计算资源抽象化之后，我觉得这个统一调度应该是非常有必要。  

#### 指标

- 延迟  每个请求、响应的平均耗时  
- 吞吐量  即单位时间内处理请求的数量  


几个度量:

1. 线程数量 / 连接数量(高IO)
2. IO（磁盘/网络）/内存度量
3. TPS，RT（通常和延迟是一个概念）
http://www.ha97.com/5095.html TPS QPS  
https://www.cnblogs.com/longxiaojiangi/p/9259745.html  

数据库优化、JVM优化、主机优化（内存、网络、IO）、应用程序优化（算法优化）

## 线程安全

可见性 原子性 有序性

### synchronized

资源  
锁  
锁的粒度  

