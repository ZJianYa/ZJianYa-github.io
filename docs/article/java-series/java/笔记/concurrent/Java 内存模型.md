
首先你得看看 OS 底层支持，然后你还得看看 Java 内存模型。  
Java 编译器和 CPU 都可能做重排序。  
本文主要参考《 Java 并发编程的艺术》第三章

## 内存模型

CPU 缓存中和主存可能出现不一致。  

### 可见性和有序性

从 JDK 5 开始，Java 使用新的 JSR-133 内存模型（本文都是以此为基础来讲述线程安全性的）。 JSR-133使用 `happens-before` 的概念来阐述操作之间的内存可见性。  
通过一系列的可见性的规则，进而保证了程序的有序性，最终也就“实现了”上面期望的（加锁的）多条语句打包执行。  

`happens-before` 本质上是要消除缓存引起脏读，可以理解为前面的操作结果相对于后面的读操作必须可见，即并没有要消除 CPU 乱序的意思。  
如前所述，**通过保证可见性，进而实现了多线程下程序执行的有序性**（这是我自己的表达，要权威描述还是看官方文档吧）。  

### happens-before

happens-before 里面有4条很重要的规则：

1. 程序的顺序性规则  
  一个线程中的操作，happens-before 于其后的任意操作。  
  和“底层支撑”中提到的的 `as-if-serial` 基本一个意思： 前面的操作结果对后续操作可见，不管怎样编译优化、乱序执行。  
2. 监视器锁（ synchronized )规则  
  对一个锁的解锁，happen-before 于随后的对这个锁的加锁。  
  （对底层了解比较深的，应该知道 synchronized 本质上是使用管程实现的，我们这里既不会聊管程，也不会聊信号量，否则又要触及 OS 的一些知识，不过 JCU 里确实也提供了“管程”和“信号量”）  
3. volatile 变量规则  
  对一个 volatile 域的写， happen-before 于其后任意对 volatile 域的读。  
4. 传递性  
  指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。  

特别强调的是即便是在多线程中，也保证这个规则。特别是对于共享变量的 happen-before 规则，直接跨线程的。  

还有 3 条和线程生命周期/对象生命周期相关的规则：

1. 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
2. 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
3. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。  
4. 对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。  
