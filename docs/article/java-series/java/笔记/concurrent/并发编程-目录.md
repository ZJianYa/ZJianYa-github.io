
## 01 可见性 原子性 有序性

不保证可见性，会因为缓存引发脏读问题  
不保证原子性，会因为线程切换引发问题  
有序性和双检锁

## 02 Java内存模型 / 消除01的问题

内存模型 volatile happen-before 规则及传递性  
final 和 双检锁

## 03  synchronized  资源和锁  

## 04 synchronized 资源和锁  
  
原子性本质：中间状态不可见，也不可修改  

## 05 死锁和解决办法

## 06 wait-notify

## 07 安全性/活跃性/性能问题

安全性：是数据竞争引起的  
活跃性：死锁/活锁/饥饿
性能：阿姆达尔定律  吞吐量/并发量/RT

## 08 管程

## 09 Java的生命周期

线程状态监测

## 10 应该创建多少线程才合适

## 11 局部变量是线程安全的

方法栈：方法的地址，栈内变量的值，引用变量的值  
线程封闭：连接池 Connection 采用了线程封闭技术

## 12 编写线程安全的对象

略

## 13 总结 1~12

锁 私有的、不可变的、不可重用的（Integer 这种是可重用的)
InterruptedException 的坑

## 14 lock 和 condition

解决死锁，更加灵活；可见性，可重入，公平性，最佳实践  
JDK 里提供的可编程的锁，利用 volatile 的 happens-before 原则 实现了锁。  
非公平锁的场景应该是线程释放锁之后，如果来了一个线程获取锁，则不必去排队可直接尝试获取。  

## 15 lock 和 condition

condition  

## 16 Semaphore  

限流器，池化资源  

## 17 ReadWriteLock 

实现一个Java缓存。 坑： 

## 18 StampedLock

比 ReentrantReadWriteLock 更高效？  
StampedLock 的错误用法
TODO 数据库的乐观锁、悲观锁，真的如其所说？  

## 19 CountDownLatch / CyclicBarrier

## 20 并发容器的坑

同步容器：Collections.synchronizedList(new ArrayList());  Vector Stack HashTable
并发容器：List（CopyOnWriteArrayList） Map（ConcurrentHashMap ConcurrentSkipListMap） Set Queue/Deque
阻塞队列 非阻塞队列 单端队列 双端队列 有界队列 无界队列

## 21 原子类 / 无锁工具

CAS 原理， CAS + 自旋， BAB

## 22 Executor  

## 23 Future

## 24 CompletableService  

## 25 CompletionService  

## 26 Fork / Join

## 答疑

## 28 Immutablebility

## 29 copy-on-write

## 30 Threadlocal

## 31 Guarded Suspension

## 32 Balking  

## 33 Thread-Per-Message

## 34 Worker Thread 模式

## 35 两阶段终止模式

## 36 生产者-消费者模式

## 37 答疑

## 38 案例分析 RateLimiter

## 39 案例分析 Netty

## 40 案例分析 Disruptor

## 41 HikariCP

## 42 Actor

## 43 STM

## 44 协程

## 45 CSP
