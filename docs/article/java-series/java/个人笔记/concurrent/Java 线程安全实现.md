
## volatile

Volatile 变量修饰符如果使用恰当的话,它比 synchronized 的使用和执行成本会更低,因为它不会引起线程上下文的切换和调度。  
volatile 变量修饰的共享变量，进行写操作的时候会多出一行汇编代码 （Java 代码转成汇编代码），即一个 Lock 前缀的指令（Lock# 信号），即插入指令屏障。  

## synchronized

使用 monitorenter 和 monitorexit 指令实现，JVM 要保证每个 monitorenter 必须有对应的 monitorexit 与之配对。  
锁存在 Java 对象头里。如果对象是数组类型,则虚拟机用 3 个 Word(字宽)存储对象头,如果对象是非数组类型,则用 2 字宽存储对象头。  
在 32 位虚拟机中,一字宽等于四字节,即 32bit。  
3个字宽分别存储：存储对象的 hashCode 或锁信息等; 存储到对象类型数据的指针； 数组的长度(如果当前对象是数组)。  

Java SE1.6 里锁一共有四种状态,无锁状态,偏向锁状态,轻量级锁状态和重量级锁状态,它会 随着竞争情况逐渐升级。  
锁可以升级但不能降级,意味着偏向锁升级成轻量级锁后不能降级成偏向锁，目的是为了 高获得锁和释放锁的效率。  

## 类库

### lock condiction

