# 概述

## 读前须知

如果你仅仅是想对 Java 并发编程有一个整体上的、系统的（不细致的）了解，这篇文章还是能有所帮助的（我尽量做到不挖坑埋人）。  
这篇文章仅适合对 Java 多线程有点基础的同学，不适合大牛也不适合小牛，也不适合面试（后续我还是会写篇对面试有帮助的文章）。  

我为啥起名叫底层支持，而不是底层原理，因为我觉得只是把逻辑捋顺还不能称之为原理，就好像知道了 API 的定义和使用方法，断然不能说你了解了 API 的实现逻辑。  
下面一段是废话（尽管上面可能也是一堆废话），看干货的可以直接跳过。  

我个人的观点：从逻辑上讲，并发编程知识并非十分高深，但是里面涉及很多繁杂的概念，且需要的纵向知识比较多一点。  
但是计算机语言知识往往是按层来分的，比如硬件-->汇编语言-->C/C++-->Java/Python/PHP/JavaScript，所以并发编程会显得比较“深”。  
而且有些知识因为中外语言的差异，以及本身技术理论本身传达就容易发生偏差等原因，导致很多非技术因素干扰我们的学习，所以并发编程会显得比较“难”。  

## 为啥会出现多线程

不讲为啥会出现多线程，线程和进程的关系也不讲，他们俩在内存和 CPU 上咋“玩游戏”的也不讲，内核线程和用户线程也不讲，CPU核数（这里的核和前面的核实一个核吗？）和线程关系也不讲。这里要聚焦在安全这个话题上。  

## 为啥会出现线程不安全

```
/**
 * 假设多个线程只能操作 store 和 load 方法
 * @author zhangln
 *
 */
public class VolatileExample {

    int a = 0;
    int b = 1;

    public void store() {
        a = 2;
        b = 3;
    }

    public void load() {
        // 这里的 b 可能是多少？
        if (a > 0) {
            // 这里的 b 可能是多少？
        }
    }
}
``` 

Java 编译器和 CPU 都可能做重排序。  

### 重排序（或者说有序性）

常见的处理器都不允许对存在数据依赖的操作做重排序（这里说的是以单线程为前提），但是部分处理器，允许写-读操作重排序。  
啥叫数据依赖？比如： `a = 1, b = 1 ;` 两个语句之间没有依赖，他们重排序没问题； `a = 1 , b = a + 1 ;` 两个语句之间就有数据依赖，断然不能重排序。  

所以即便 CPU 可以乱序执行也要遵循 `as-if-serial` （这是个单线程内的概念） 原则。其语义是：不管怎么重排序，（单线程）程序的结果不能被改变。比如 `a = 1, b = 1 , c = a + b ；` 怎么乱序执行，都不应该出现 `c = 1` 的结果，其实还是遵循了不能破坏数据依赖的原则。  
即便如此，显然在多线程的情况下还是会出现异常。

现在我们可以罗列出其中两种可能的执行情况： 

情况1：
| 线程A     | 线程 B |
| --------- | ------ |
| int a = 0 | xxx    |
| int a = 0 | xxx    |

情况2：
| 线程A     | 线程 B |
| --------- | ------ |
| int a = 0 | xxx    |
| int a = 0 | xxx    |

### 原子操作

## 硬件相关的术语

这些术语了解一下，以便理解后面内容。

| 中文翻译     | 术语                   | 解释                                                                                                                                                                                                                                         |
| ------------ | ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 内存屏障     | memory barriers        | 一组处理器指令，实现对内存操作的顺序限制                                                                                                                                                                                                     |
| 原子操作     | Atomic operations      | 不可中断的一个或者一系列操作                                                                                                                                                                                                                 |
| 缓冲行       | cache line             | 缓冲中可以分配的最小存储单元。处理器填写缓存线时，会加载整个缓存线，需要使用多个主内存读周期（这里我也不懂什么叫缓冲行，缓存线，对应了硬件的什么区域，但是并不影响下面的阅读）                                                               |
| 缓冲行填充   | cache line fill        | 如果处理器识别到从内存中读取的操作数是可缓存的，可以将缓存行读取并放入到缓存（L1,L2,L3的或所有）                                                                                                                                             |
| 比较并交换   | Compare and Swap       | CAS 操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。                                                                                   |
| CPU 流水线   | CPU pipeline           | CPU 流水线的工作方式就象工业生产上的装配流水线，在 CPU 中由 5~6 个不同功能的电路单元组成一条指令处理流水线，然后将一条 X86 指令分成 5~6 步后再由这些电路单元分别执行，这样就能实现在一个 CPU 时钟周期完成一条指令，因此提高 CPU 的运算速度。 |
| 内存顺序冲突 | Memory order violation | 内存顺序冲突一般是由假共享引起，假共享是指多个 CPU 同时修改同一个缓存行的不同部分而引起其中一个 CPU 的操作无效，当出现这个内存顺序冲突时，CPU 必须清空流水线。                                                                               |

我们都知道线程安全是因为无法保证下面3个方面（原子性、可见性、有序性）导致的，接下来就每个方面来展开聊聊吧。  

## 如何解决线程不安全的问题

### 原子操作

处理器使用基于对 “缓存加锁或总线加锁” 的方式来实现多处理器之间的原子操作，更多详情这不再展开叙述，可以看 《Java并发编程的艺术》（这本书里我看了半天 2.3 章节，觉得怎么只讲对数据操作的原子性啊？后来想想也是，数据库事务本质上保证的也是数据操作的原子性）。  

不过如果只能保证单个操作的原子性，比如读一个值、写一个值的话，那岂不是太局限了，可不可以像数据库一样来保证一组操作不被拆开呢？我认为不可以，即便是数据库本质上也没有办法保证（加锁的）多条语句是打包执行的。  
不过好在 JMM （Java 内存模型） 规范提供了一套机制，来保证即便是多线程的情况下，也可以有序执行，这种有序性从其实就保证了多个操作不被拆开。  
详情看 Java 内存模型。  

### 可见性和有序性









最后我们可以再看看，修改后的代码，及其中的问题：

```
/**
 * 假设多个线程只能操作 store 和 load 方法
 * @author zhangln
 *
 */
public class VolatileExample {

    int a = 0;
    volatile int b = 1;

    public void store() {
        a = 2;
        b = 3;
    }

    public void load() {
        // 这里的 b 可能是多少？
        if (a > 0) {
            // 这里的 b 可能是多少？
        }
    }
}
```

现在想想，还会出现之前的问题吗？为什么？ 

情况1：
| 线程A     | 线程 B | 能否出现 | 为什么 |
| --------- | ------ | -------- | ------ |
| int a = 0 | xxx    |          |        |
| int a = 0 | xxx    |          |        |

情况2：
| 线程A     | 线程 B | 能否出现 | 为什么 |
| --------- | ------ | -------- | ------ |
| int a = 0 | xxx    |          |        |
| int a = 0 | xxx    |          |        |

我们再罗列一下可能出现的情况：

情况3：
| 线程A     | 线程 B | 能否出现 | 为什么 |
| --------- | ------ | -------- | ------ |
| int a = 0 | xxx    |          |        |
| int a = 0 | xxx    |          |        |

情况4：
| 线程A     | 线程 B | 能否出现 | 为什么 |
| --------- | ------ | -------- | ------ |
| int a = 0 | xxx    |          |        |
| int a = 0 | xxx    |          |        |

如何验证呢，其实开两个线程，然后打上 debug 断点就可以溜溜的验证了，这是做数据库不能比拟的（除非他们 down 下源码然后 DEBUG 测试）。 

