
本文的目标旨在，对轻量级进程、用户线程、内核线程三者及其关系有一个比较好的

## 定义

在现代操作系统中，进程是资源管理的最小单元，线程是程序执行的最小单元。  

最初的进程定义都包含程序、资源及其执行三部分。  
其中程序通常指代码，资源在操作系统层面上通常包括内存资源（地址空间）、IO资源（打开的文件）、信号处理、用户信息等部分，而程序的执行通常理解为执行上下文，包括对cpu的占用，后来发展为线程。  
线程有自己的私有数据：程序计数器，栈空间以及寄存器。  

关于线程的概念不多说了，内核级和用户级线程的定义网上也有，简单的说：内核级就是操作系统内核支持，用户级就是函数库实现（也就是说，不管你操作系统是不是支持线程的，我都可以在你上面用多线程编程）

## Why

* 最主要的目的就是更好的支持SMP以及减小（进程/线程）上下文切换开销。  
* 现实中一个应用往往需要并发处理多个任务，比如 Tomcat 中一个 APP 要同时处理一定并发量的用户请求，类似的还有很多。  
* 如果采用多进程的方法，则有如下问题：
  * fork一个子进程的消耗是很大的，fork是一个昂贵的系统调用，即使使用现代的写时复制(copy-on-write)技术。
  * 各个进程拥有自己独立的地址空间，进程间的协作需要复杂的IPC技术，如消息传递和共享内存等。

## 优缺点

1. 由于共享进程的代码和全局数据，锁线程间的通信方便。  
2. 由于线程共享进程的地址空间，因此可能会导致竞争，即线程安全问题。  

## 线程的演进

在线程概念出现以前，为了减小进程切换的开销，操作系统设计者逐渐修正进程的概念，逐渐允许将进程所占有的资源从其主体剥离出来，允许某些进程共享一部分资源，例如文件、信号，数据内存，甚至代码，这就发展出轻量进程的概念。  
Linux内核在2.0.x版本就已经实现了轻量进程 LWP ，应用程序可以通过一个统一的clone()系统调用接口，用不同的参数指定创建轻量进程还是普通进程。  
在内核中，clone()调用经过参数传递和解释后会调用do_fork()，这个核内函数同时也是fork()、vfork()系统调用的最终实现。  

如果操作系统没有提供“创建线程”的函数（比如Linux 2.4及以前的版本，因为Linux刚诞生那时候，还没有“线程”的概念，能处理多“进程”就不错了），当然你程序员也没办法在操作系统上创建线程。所以，Linux 2.4内核中不知道什么是“线程”，只有一个“task_struct”的数据结构，就是进程。那么，后来随着科学技术的发展，大家提出线程的概念，而且，线程有时候的确是个好东西，于是，我们希望Linux能加入“多线程”编程。

有两家公司参与了对LinuxThreads的改进（向他们致敬）：IBM启动的NGTP(Next Generation POSIX Threads)项目，以及红帽Redhat公司的NPTL（Native POSIX Thread Library），IBM那个项目，在2003年因为种种原因放弃了，大家都转到NPTL这个项目来了。

在Linux 2.6的内核版本中，这个NPTL项目怎么做的呢？并不是在Linux内核中加了一个“线程”，仍然和原来一样，进程（其实，进程线程就是个概念，对于计算机，只要能高效的实现这个概念就行，程序员能用就OK，管它究竟怎么实现的），不过，用的clone实现的轻量级进程，内核又增加了若干机制来保证线程的表现和POSIX相同，最关键的一点，用户调用pthread库创建的一个线程，会在内核创建一个“线程”，这就是所谓的1：1模型。所以，Linux下，是有“内核级”线程的，网上很多说Linux是用户级线程，都是不完整的，说的Linux很早以前的版本（现在Linux已经是4.X的版本了）。  

还有个 pthread 的问题，pthread是个线程函数库，他提供了一些函数，让程序员可以用它来创建，使用线程。那么问题是，这个函数库里面的函数，比如 pthread_create 创建线程的函数，他是怎么实现的呢？他如果是用以前的方法，那程序员用它来创建的线程，还是“用户级”线程；如果它使用了NPTL方式创建线程，那么，它创建的线程，就是“内核级”线程。

本段大部分内容来自：  
链接：https://www.zhihu.com/question/35128513/answer/148038406
作者：大河  

采用内核线程，利于并发使用多处理器的资源；采用用户线程利于减少上下文切换开销。  
在目前的商用系统中，通常都将两者结合起来使用，既提供核心线程以满足smp系统的需要，也支持用线程库的方式在用户态实现另一套线程机制，此时一个核心线程同时成为多个用户态线程的调度者。  
正如很多技术一样，"混合"通常都能带来更高的效率，但同时也带来更大的实现难度，出于"简单"的设计思路，Linux从一开始就没有实现混合模型的计划，但它在实现上采用了另一种思路的"混合"。  

当核内既支持进程也支持线程时，就可以实现线程-进程的"多对多"模型，即一个进程的某个线程由核内调度，而同时它也可以作为用户级线程池的调度者，选择合适的用户级线程在其空间中运行。  
这就是前面提到的"混合"线程模型，既可满足多处理机系统的需要，也可以最大限度的减小调度开销。  
绝大多数商业操作系统（如Digital Unix、Solaris、Irix）都采用的这种能够完全实现POSIX1003.1c标准的线程模型。  

### LWP

将线程调度等同于进程调度，交给核心完成，因此每个LWP都是一个独立的线程调度单元。即使有一个LWP在系统调用中阻塞，也不会影响整个进程的执行。

轻量级进程具有局限性。首先，大多数LWP的操作，如建立、析构以及同步，都需要进行系统调用。系统调用的代价相对较高：需要在user mode和kernel mode中切换。其次，每个LWP都需要有一个内核线程支持，因此LWP要消耗内核资源（内核线程的栈空间）。因此一个系统不能支持大量的LWP。

### 用户线程

这里所说的用户线程，指完全在核外实现的多线程，调度也在用户态完成。  
显然，这种核外的线程调度器实际上只需要完成线程运行栈的切换，调度开销非常小，但同时因为核心信号（无论是同步的还是异步的）都是以进程为单位的，因而无法定位到线程，所以这种实现方式不能用于多处理器系统，而这个需求正变得越来越大，因此，在现实中，纯用户级线程的实现，除算法研究目的以外，几乎已经消失了。
这种模型对应着恐龙书中提到的多对一线程模型，其缺点是一个用户线程如果阻塞在系统调用中，则整个进程都将会阻塞。  

### 内核线程

内核线程就是内核的分身，一个分身可以处理一件特定事情。  
这在处理异步事件如异步IO时特别有用。  
内核线程的使用是廉价的，唯一使用的资源就是内核栈和上下文切换时保存寄存器的空间。  
支持多线程的内核叫做多线程内核(Multi-Threads kernel )。  

### 加强版的用户线程——用户线程+LWP

这种模型对应着恐龙书中多对多模型。  
用户线程库还是完全建立在用户空间中，因此用户线程的操作还是很廉价，因此可以建立任意多需要的用户线程。  
LWP 还是和前面提到的一样，具有内核线程支持，是内核的调度单元，并且用户线程的系统调用要通过LWP，因此进程中某个用户线程的阻塞不会影响整个进程的执行。  
用户线程库将建立的用户线程映射到 LWP 上，LWP 与用户线程的数量不一定一致。当内核调度到某个 LWP 上时，此时与该 LWP 关联的用户线程就被执行。  

小结：
很多文献中都认为轻量级进程就是线程，实际上这种说法并不完全正确，从前面的分析中可以看到，只有在用户线程完全由轻量级进程构成时，才可以说轻量级进程就是线程。  

## 其他参考

https://www.ibm.com/developerworks/cn/linux/kernel/l-thread/  
http://www.cnitblog.com/tarius.wu/articles/2277.html  
https://blog.csdn.net/gatieme/article/details/51892437  线程的3种实现方式，本文虽然未参考这个，但是这个也写的不错