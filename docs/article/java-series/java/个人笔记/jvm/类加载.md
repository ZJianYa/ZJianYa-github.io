# 概述

Java是静态语言吗？或许我们得先知道什么叫静态，什么叫动态，这主要是站在使用者的角度，而不是生产者的角度。  

## 类型

Java 语言的类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）。  
基本类型是由 Java 虚拟机预先定义好的。  

引用类型分为四种：类、接口、数组类和泛型参数。  
由于泛型参数会在编译过程中被擦除，因此实际上只有前三种。  
在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。  

## 加载

由类加载器读取 .class 文件，类加载器分为 3 种：

- 启动类加载器（bootstrap class loader)
- 其他的都是 java.lang.ClassLoader
  - 扩展类加载器（extension class loader）  
    扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。
  - 应用类加载器（application class loader）  
    应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。  
  - 自定义  
    除了由 Java 核心类库提供的类加载器外，我们还可以加入自定义的类加载器，来实现特殊的加载方式。举例来说，我们可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。  

在加载类的时候，通常会先访问上级类加载器，如果上级已经加载，则不再加载，否则使用当前类加载器加载。  

在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器（extension class loader）和应用类加载器（application class loader），均由 Java 核心类库提供。  

Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。

除了加载功能之外，类加载器还提供了命名空间的作用。

在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。  

### 个人理解

类加载器，实现了应用的隔离。  
双亲委派模型，实现了通用类型的共享。  

## 链接

链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。

准备阶段会为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。  
部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。  

Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。

## 初始化

如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 `< clinit >`。

TODO