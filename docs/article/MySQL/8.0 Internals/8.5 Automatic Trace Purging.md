By default, each new trace overwrites the previous trace. Thus, if a statement contains substatements (example: invokes stored procedures, stored functions, triggers), the top statement and substatements each generate one trace, but at the execution's end only the last substatement's trace is visible. A user who wants to see the trace of another substatement, can enable/disable tracing around the desired substatement, but this requires editing the routine's code, which may not be possible. Another solution is to tune trace purging.  

默认，每一个新的 trace 会覆盖前面的 trace 。因此，如果一个 statement 包含了子句（如存储过程，存储函数，触发器），则 top 语句和子语句均会生成一个跟踪，但是在执行结束时，只有最后一个子语句的跟踪才可见。想要查看另一个子语句的跟踪的用户可以启用/禁用对所需子语句的跟踪，但这需要编辑例程的代码，这可能是不可能的。另一个解决方案是调整跟踪清除。  