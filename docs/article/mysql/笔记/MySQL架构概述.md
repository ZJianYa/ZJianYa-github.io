# 概述

- 查询语句是怎样执行的
- 更新语句是怎样执行的

Server层的功能都是跨存储引擎的，比如存储过程、触发器、视图等。包括：连接器、缓存区、分析器、优化器、执行器，以及内置函数比如存储过程、触发器、视图。  

## 连接器

- 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。  
  一般建议尽量用长连接，但是全部使用长连接之后，内存占用涨的会比较快，因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里的，这些资源会在连接断开的时候才释放。如果内存占用太大，被系统强行杀掉（OOM），看起来就好像 MySQL 异常重启了。  
- 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。  

## 查询缓存

但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。  

查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

这和Mybatis的缓存有些相似。  

好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：

mysql> select SQL_CACHE * from T where ID=10；

需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。

## 分析器

词法、语法分析

## 优化器

预校验，生成执行计划（选择索引，选择合理的算法）

## 执行器

调用引擎  

对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。  

你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。  
这个值就是在执行器每次调用引擎获取数据行的时候累加的。  
在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。  
